---
title: Workflow Examples
description: Practical workflow examples for common Osmedeus use cases
icon: "book-copy"
---

# Workflow Examples

This document provides practical workflow examples for common security automation use cases.

## 1. Module Examples

### Basic Subdomain Enumeration

```yaml
kind: module
name: subdomain-enum
description: "Enumerate subdomains using multiple tools"
tags: "recon, subdomain"

params:
  - name: threads
    default: 10
  - name: wordlist
    default: "{{Data}}/wordlists/subdomains-top1m.txt"

steps:
  - name: subfinder
    type: bash
    command: "subfinder -d {{Target}} -all -o {{Output}}/subfinder.txt"
    timeout: 30m

  - name: amass-passive
    type: bash
    command: "amass enum -passive -d {{Target}} -o {{Output}}/amass.txt"
    timeout: 1h

  - name: merge-results
    type: function
    depends_on:
      - subfinder
      - amass-passive
    functions:
      - "appendFile('{{Output}}/all-subs.txt', '{{Output}}/subfinder.txt')"
      - "appendFile('{{Output}}/all-subs.txt', '{{Output}}/amass.txt')"
      - "sortUnix('{{Output}}/all-subs.txt', '{{Output}}/subdomains.txt')"
      - "db_total_subdomains('{{Output}}/subdomains.txt')"
    exports:
      subdomain_count: "{{_result}}"
```

### HTTP Probing with Foreach

```yaml
kind: module
name: http-probe
description: "Probe subdomains for live HTTP services"
tags: "recon, http"

params:
  - name: threads
    default: 50
  - name: timeout
    default: "10"

steps:
  - name: httpx-probe
    type: bash
    command: >
      httpx -l {{Output}}/subdomains.txt
      -threads {{threads}}
      -timeout {{timeout}}
      -json
      -o {{Output}}/httpx.jsonl
    timeout: 2h

  - name: import-results
    type: function
    depends_on:
      - httpx-probe
    functions:
      - "db_import_asset_from_file('{{Workspace}}', '{{Output}}/httpx.jsonl')"
      - "db_total_urls('{{Output}}/httpx.jsonl')"
```

### Vulnerability Scanning

```yaml
kind: module
name: vuln-scan
description: "Run vulnerability scans with Nuclei"
tags: "vuln, scan"

params:
  - name: threads
    default: 25
  - name: severity
    default: "critical,high,medium"
  - name: rate_limit
    default: 150

steps:
  - name: nuclei-scan
    type: bash
    pre_condition: "fileLength('{{Output}}/urls.txt') > 0"
    command: >
      nuclei -l {{Output}}/urls.txt
      -t {{Data}}/nuclei-templates/
      -severity {{severity}}
      -rate-limit {{rate_limit}}
      -c {{threads}}
      -json
      -o {{Output}}/nuclei.jsonl
    timeout: 4h

  - name: import-vulns
    type: function
    depends_on:
      - nuclei-scan
    functions:
      - "db_import_vuln_from_file('{{Workspace}}', '{{Output}}/nuclei.jsonl')"
      - "log_info('Vulnerabilities imported')"

  - name: notify-critical
    type: function
    depends_on:
      - import-vulns
    pre_condition: "db_select_vuln_critical() > 0"
    function: "notifyTelegram('Critical vulnerabilities found for {{Target}}')"
```

---

## 2. Flow Examples

### Full Reconnaissance Flow

```yaml
kind: flow
name: full-recon
description: "Complete reconnaissance workflow"
tags: "recon, full"

params:
  - name: threads
    default: 20

modules:
  - name: subdomain-enum
    path: modules/subdomain-enum.yaml
    params:
      threads: "{{threads}}"

  - name: http-probe
    path: modules/http-probe.yaml
    depends_on:
      - subdomain-enum
    condition: "fileLength('{{Output}}/subdomains.txt') > 0"

  - name: screenshot
    path: modules/screenshot.yaml
    depends_on:
      - http-probe
    condition: "fileLength('{{Output}}/urls.txt') > 0"

  - name: vuln-scan
    path: modules/vuln-scan.yaml
    depends_on:
      - http-probe
    params:
      threads: "{{threads}}"

  - name: report-gen
    path: modules/report-gen.yaml
    depends_on:
      - vuln-scan
      - screenshot
```

### Flow with Decision Routing

```yaml
kind: flow
name: adaptive-scan
description: "Adaptive scanning based on target size"
tags: "adaptive, smart"

modules:
  - name: initial-enum
    path: modules/quick-enum.yaml

  - name: check-size
    path: modules/count-assets.yaml
    depends_on:
      - initial-enum
    decision:
      switch: "{{asset_count_range}}"
      cases:
        "small": { goto: deep-scan }
        "medium": { goto: standard-scan }
        "large": { goto: shallow-scan }
      default: { goto: standard-scan }

  - name: deep-scan
    path: modules/deep-scan.yaml

  - name: standard-scan
    path: modules/standard-scan.yaml

  - name: shallow-scan
    path: modules/shallow-scan.yaml

  - name: finalize
    path: modules/finalize.yaml
    depends_on:
      - deep-scan
      - standard-scan
      - shallow-scan
```

---

## 3. Fragment Examples

### Common Setup Fragment

```yaml
kind: fragment
name: common-setup
description: "Common setup steps for all modules"

steps:
  - name: create-directories
    type: function
    functions:
      - "createFolder('{{Output}}/raw')"
      - "createFolder('{{Output}}/processed')"
      - "createFolder('{{Output}}/reports')"

  - name: log-start
    type: function
    function: "log_info('Starting scan for {{Target}}')"
```

### Data Cleanup Fragment

```yaml
kind: fragment
name: data-cleanup
description: "Clean and deduplicate scan results"

params:
  - name: input_file
    required: true
  - name: output_file
    required: true

steps:
  - name: sort-unique
    type: function
    function: "sortUnix('{{input_file}}', '{{output_file}}')"

  - name: remove-blanks
    type: function
    function: "remove_blank_lines('{{output_file}}')"

  - name: log-count
    type: function
    function: "log_info('Cleaned: ' + fileLength('{{output_file}}') + ' lines')"
```

### Notification Fragment

```yaml
kind: fragment
name: notify-results
description: "Send notifications with scan results"

params:
  - name: message_prefix
    default: "Scan completed"

steps:
  - name: prepare-summary
    type: function
    functions:
      - "log_info('{{message_prefix}} for {{Target}}')"

  - name: send-telegram
    type: function
    pre_condition: "os_getenv('TELEGRAM_BOT_TOKEN') != ''"
    function: >
      notifyTelegram('{{message_prefix}} for {{Target}}\n' +
        'Subdomains: ' + db_select_total_subdomains() + '\n' +
        'URLs: ' + db_select_total_urls() + '\n' +
        'Vulns: ' + db_select_total_vulns())

  - name: send-webhook
    type: function
    pre_condition: "os_getenv('WEBHOOK_URL') != ''"
    function: >
      sendWebhookEvent('scan_complete', {
        target: '{{Target}}',
        subdomains: db_select_total_subdomains(),
        vulns: db_select_total_vulns()
      })
```

---

## 4. Using Fragments in Modules

### Module with Fragment Include

```yaml
kind: module
name: subdomain-scan-with-cleanup
description: "Subdomain scan with cleanup fragment"
tags: "recon, subdomain"

includes:
  - path: fragments/common-setup.yaml
    fragment_name: setup
  - path: fragments/data-cleanup.yaml
    fragment_name: cleanup
  - path: fragments/notify-results.yaml
    fragment_name: notify

steps:
  # Run setup fragment first
  - name: run-setup
    type: fragment-step
    fragment_name: setup

  - name: subfinder
    type: bash
    depends_on:
      - run-setup
    command: "subfinder -d {{Target}} -o {{Output}}/raw/subfinder.txt"

  - name: amass
    type: bash
    depends_on:
      - run-setup
    command: "amass enum -passive -d {{Target}} -o {{Output}}/raw/amass.txt"

  - name: merge
    type: function
    depends_on:
      - subfinder
      - amass
    functions:
      - "appendFile('{{Output}}/raw/all.txt', '{{Output}}/raw/subfinder.txt')"
      - "appendFile('{{Output}}/raw/all.txt', '{{Output}}/raw/amass.txt')"

  # Run cleanup fragment with overrides
  - name: clean-results
    type: fragment-step
    depends_on:
      - merge
    fragment_name: cleanup
    override:
      input_file: "{{Output}}/raw/all.txt"
      output_file: "{{Output}}/processed/subdomains.txt"

  - name: update-db
    type: function
    depends_on:
      - clean-results
    function: "db_total_subdomains('{{Output}}/processed/subdomains.txt')"

  # Run notification fragment
  - name: notify
    type: fragment-step
    depends_on:
      - update-db
    fragment_name: notify
    override:
      message_prefix: "Subdomain enumeration completed"
```

### Fragment Chain Example

```yaml
kind: module
name: full-pipeline
description: "Full pipeline using chained fragments"

includes:
  - path: fragments/common-setup.yaml
    fragment_name: setup
  - path: fragments/data-cleanup.yaml
    fragment_name: cleanup
  - path: fragments/notify-results.yaml
    fragment_name: notify

steps:
  - name: init
    type: fragment-step
    fragment_name: setup

  - name: scan-1
    type: bash
    depends_on:
      - init
    command: "tool1 -t {{Target}} -o {{Output}}/raw/tool1.txt"

  - name: clean-1
    type: fragment-step
    depends_on:
      - scan-1
    fragment_name: cleanup
    override:
      input_file: "{{Output}}/raw/tool1.txt"
      output_file: "{{Output}}/processed/tool1.txt"

  - name: scan-2
    type: bash
    depends_on:
      - clean-1
    command: "tool2 -i {{Output}}/processed/tool1.txt -o {{Output}}/raw/tool2.txt"

  - name: clean-2
    type: fragment-step
    depends_on:
      - scan-2
    fragment_name: cleanup
    override:
      input_file: "{{Output}}/raw/tool2.txt"
      output_file: "{{Output}}/processed/final.txt"

  - name: finish
    type: fragment-step
    depends_on:
      - clean-2
    fragment_name: notify
```

---

## 5. Advanced Examples

### Remote Execution (Docker)

```yaml
kind: module
name: docker-scan
description: "Run scans in Docker containers"
tags: "docker, isolated"

steps:
  - name: nuclei-docker
    type: remote-bash
    step_runner: docker
    step_runner_config:
      image: "projectdiscovery/nuclei:latest"
      volumes:
        - "{{Output}}:/output"
        - "{{Data}}/nuclei-templates:/templates"
      network: "host"
    command: "nuclei -l /output/urls.txt -t /templates/ -o /output/nuclei.json"
    step_remote_file: "/output/nuclei.json"
    host_output_file: "{{Output}}/nuclei.json"
    timeout: 2h
```

### Remote Execution (SSH)

```yaml
kind: module
name: ssh-scan
description: "Run scans on remote server via SSH"
tags: "ssh, distributed"

params:
  - name: ssh_host
    required: true
  - name: ssh_user
    default: "scanner"
  - name: ssh_key
    default: "~/.ssh/id_rsa"

steps:
  - name: remote-nuclei
    type: remote-bash
    step_runner: ssh
    step_runner_config:
      host: "{{ssh_host}}"
      user: "{{ssh_user}}"
      key_file: "{{ssh_key}}"
      workdir: "/tmp/scan"
    command: "nuclei -l urls.txt -o results.json"
    timeout: 2h
```

### LLM-Assisted Analysis

```yaml
kind: module
name: llm-analysis
description: "Use LLM for vulnerability analysis"
tags: "llm, analysis"

steps:
  - name: load-vulns
    type: function
    function: "readFile('{{Output}}/nuclei.json')"
    exports:
      vuln_data: "{{_result}}"

  - name: analyze
    type: llm
    depends_on:
      - load-vulns
    messages:
      - role: system
        content: "You are a security analyst. Analyze vulnerabilities and provide remediation guidance."
      - role: user
        content: "Analyze these findings and prioritize them:\n{{vuln_data}}"
    llm_config:
      model: "gpt-4"
      temperature: 0.3
      max_tokens: 4000
    exports:
      analysis: "{{_result}}"

  - name: save-report
    type: function
    depends_on:
      - analyze
    function: "save_content('{{analysis}}', '{{Output}}/llm-analysis.md')"
```

### Scheduled Continuous Monitoring

```yaml
kind: module
name: continuous-monitor
description: "Continuous monitoring with diff detection"
tags: "monitor, continuous"

triggers:
  - name: daily-scan
    on: cron
    schedule: "0 2 * * *"
    enabled: true

steps:
  - name: enumerate
    type: bash
    command: "subfinder -d {{Target}} -o {{Output}}/current-subs.txt"

  - name: check-diff
    type: function
    depends_on:
      - enumerate
    functions:
      - "extractDiff('{{Output}}/baseline-subs.txt', '{{Output}}/current-subs.txt')"
    exports:
      new_subs: "{{_result}}"

  - name: notify-new
    type: function
    depends_on:
      - check-diff
    pre_condition: "len('{{new_subs}}') > 0"
    function: "notifyTelegram('New subdomains found for {{Target}}:\n{{new_subs}}')"

  - name: update-baseline
    type: function
    depends_on:
      - notify-new
    function: "moveFile('{{Output}}/current-subs.txt', '{{Output}}/baseline-subs.txt')"
```

---

## 6. Workflow Inheritance Examples

### Base Module

```yaml
# modules/base-enum.yaml
kind: module
name: base-enum
description: "Base subdomain enumeration module"
tags: "recon, subdomain, base"

params:
  - name: threads
    default: 10
  - name: timeout
    default: "30m"
  - name: wordlist
    default: "{{Data}}/wordlists/subdomains-top1m.txt"

steps:
  - name: subfinder
    type: bash
    command: "subfinder -d {{Target}} -t {{threads}} -o {{Output}}/subfinder.txt"
    timeout: "{{timeout}}"

  - name: amass-passive
    type: bash
    command: "amass enum -passive -d {{Target}} -o {{Output}}/amass.txt"
    timeout: "{{timeout}}"

  - name: merge-results
    type: function
    depends_on:
      - subfinder
      - amass-passive
    functions:
      - "appendFile('{{Output}}/all-subs.txt', '{{Output}}/subfinder.txt')"
      - "appendFile('{{Output}}/all-subs.txt', '{{Output}}/amass.txt')"
      - "sortUnix('{{Output}}/all-subs.txt', '{{Output}}/subdomains.txt')"
```

### Fast Variant (Extends Base)

```yaml
# modules/fast-enum.yaml
kind: module
name: fast-enum
description: "Fast subdomain enumeration (reduced scope)"
extends: base-enum

# Override description and tags
tags: "recon, subdomain, fast"

override:
  # Override parameter defaults
  params:
    threads:
      default: 50
    timeout:
      default: "10m"

  # Remove amass (slow), only use subfinder
  steps:
    mode: merge
    remove:
      - amass-passive
```

### Aggressive Variant (Extends Base)

```yaml
# modules/aggressive-enum.yaml
kind: module
name: aggressive-enum
description: "Aggressive subdomain enumeration with active bruteforcing"
extends: base-enum

tags: "recon, subdomain, aggressive"

override:
  params:
    threads:
      default: 100

  # Append additional steps
  steps:
    mode: append
    steps:
      - name: bruteforce
        type: bash
        depends_on:
          - merge-results
        command: >
          shuffledns -d {{Target}}
          -w {{wordlist}}
          -r {{Data}}/resolvers.txt
          -o {{Output}}/bruteforce.txt
        timeout: 2h

      - name: final-merge
        type: function
        depends_on:
          - bruteforce
        functions:
          - "appendFile('{{Output}}/subdomains.txt', '{{Output}}/bruteforce.txt')"
          - "sortUnix('{{Output}}/subdomains.txt')"
```

### Flow Inheritance

```yaml
# flows/base-recon.yaml
kind: flow
name: base-recon
description: "Base reconnaissance flow"

params:
  - name: threads
    default: 20

modules:
  - name: subdomain-enum
    path: modules/base-enum.yaml
    params:
      threads: "{{threads}}"

  - name: http-probe
    path: modules/http-probe.yaml
    depends_on:
      - subdomain-enum

  - name: vuln-scan
    path: modules/vuln-scan.yaml
    depends_on:
      - http-probe
```

```yaml
# flows/stealth-recon.yaml
kind: flow
name: stealth-recon
description: "Stealthy reconnaissance (slow, low noise)"
extends: base-recon

tags: "recon, stealth"

override:
  params:
    threads:
      default: 5

  # Replace the aggressive vuln-scan with passive analysis
  modules:
    mode: merge
    remove:
      - vuln-scan
    modules:
      - name: passive-analysis
        path: modules/passive-analysis.yaml
        depends_on:
          - http-probe
```

---

## 7. Enhanced HTTP Examples

### API Integration Workflow

```yaml
kind: module
name: api-integration
description: "Integrate with external APIs"
tags: "api, integration"

params:
  - name: api_token
    required: true

steps:
  - name: start-scan
    type: http
    url: "https://scanner.example.com/api/v1/scans"
    method: POST
    headers:
      Authorization: "Bearer {{api_token}}"
      Content-Type: application/json
    request_body: |
      {
        "target": "{{Target}}",
        "scan_type": "full",
        "callback_url": "{{webhook_url}}"
      }
    exports:
      scan_id: "{{start_scan_http_resp.response_body}}"

  - name: wait-for-completion
    type: http
    url: "https://scanner.example.com/api/v1/scans/{{scan_id}}/status"
    method: GET
    headers:
      Authorization: "Bearer {{api_token}}"
    exports:
      scan_status: "{{wait_for_completion_http_resp.response_body}}"

  - name: download-results
    type: http
    url: "https://scanner.example.com/api/v1/scans/{{scan_id}}/results"
    method: GET
    headers:
      Authorization: "Bearer {{api_token}}"
    exports:
      results: "{{download_results_http_resp.response_body}}"

  - name: save-results
    type: function
    function: "save_content('{{results}}', '{{Output}}/api-results.json')"
```

### Webhook Notification

```yaml
kind: module
name: webhook-notify
description: "Send results to webhook"

steps:
  - name: prepare-payload
    type: function
    functions:
      - "log_info('Preparing notification payload')"
    exports:
      total_subs: "{{db_select_total_subdomains()}}"
      total_vulns: "{{db_select_total_vulns()}}"

  - name: send-slack-webhook
    type: http
    url: "{{slack_webhook_url}}"
    method: POST
    headers:
      Content-Type: application/json
    request_body: |
      {
        "text": "Scan completed for {{Target}}",
        "blocks": [
          {
            "type": "section",
            "text": {
              "type": "mrkdwn",
              "text": "*Scan Results*\n• Subdomains: {{total_subs}}\n• Vulnerabilities: {{total_vulns}}"
            }
          }
        ]
      }
```

---

## 8. Enhanced LLM Examples

### Vulnerability Analysis

```yaml
kind: module
name: llm-vuln-analysis
description: "AI-powered vulnerability analysis"
tags: "llm, analysis"

steps:
  - name: load-findings
    type: function
    function: "readFile('{{Output}}/nuclei.jsonl')"
    exports:
      vuln_data: "{{_result}}"

  - name: analyze-findings
    type: llm
    messages:
      - role: system
        content: |
          You are a senior security analyst. Analyze the vulnerability findings
          and provide:
          1. Executive summary
          2. Risk assessment
          3. Prioritized remediation steps
          4. Technical recommendations
      - role: user
        content: |
          Analyze these Nuclei findings for {{Target}}:

          {{vuln_data}}
    llm_config:
      model: gpt-4-turbo
      temperature: 0.3
      max_tokens: 4000
    exports:
      analysis: "{{analyze_findings_content}}"

  - name: save-analysis
    type: function
    function: "save_content('{{analysis}}', '{{Output}}/llm-analysis.md')"

  - name: notify
    type: function
    pre_condition: "db_select_vuln_critical() > 0"
    function: "notifyTelegram('Critical vulnerabilities found for {{Target}}. See analysis report.')"
```

### Structured Output with JSON Schema

```yaml
kind: module
name: llm-structured-analysis
description: "LLM analysis with structured JSON output"
tags: "llm, structured"

steps:
  - name: structured-analysis
    type: llm
    messages:
      - role: system
        content: "You are a security analyst. Analyze findings and return structured JSON."
      - role: user
        content: "Analyze: {{readFile('{{Output}}/findings.txt')}}"
    llm_config:
      model: gpt-4-turbo
      response_format:
        type: json_schema
        json_schema:
          name: security_analysis
          schema:
            type: object
            properties:
              executive_summary:
                type: string
              risk_level:
                type: string
                enum: [critical, high, medium, low, info]
              findings:
                type: array
                items:
                  type: object
                  properties:
                    title:
                      type: string
                    severity:
                      type: string
                    description:
                      type: string
                    remediation:
                      type: string
                  required: [title, severity, description]
              recommendations:
                type: array
                items:
                  type: string
            required: [executive_summary, risk_level, findings]
    exports:
      analysis_json: "{{structured_analysis_content}}"

  - name: save-json
    type: function
    function: "save_content('{{analysis_json}}', '{{Output}}/analysis.json')"
```

### Tool Calling for Automated Actions

```yaml
kind: module
name: llm-agent
description: "LLM agent with tool calling capabilities"
tags: "llm, agent"

steps:
  - name: intelligent-scan
    type: llm
    messages:
      - role: system
        content: |
          You are a security scanning assistant. Based on the target information,
          determine which scans would be most effective and call the appropriate tools.
      - role: user
        content: "Target: {{Target}}\nType: {{TargetType}}\nStatus: {{TargetStatusCode}}"
    tools:
      - type: function
        function:
          name: run_port_scan
          description: "Run a port scan on the target"
          parameters:
            type: object
            properties:
              scan_type:
                type: string
                enum: [quick, standard, comprehensive]
                description: "Type of port scan"
              ports:
                type: string
                description: "Ports to scan (e.g., '80,443' or 'top-1000')"
            required: [scan_type]

      - type: function
        function:
          name: run_vuln_scan
          description: "Run vulnerability scanning"
          parameters:
            type: object
            properties:
              templates:
                type: array
                items:
                  type: string
                description: "Template categories to use"
              severity:
                type: string
                enum: [critical, high, medium, low, info]
                description: "Minimum severity to report"
            required: [templates]

      - type: function
        function:
          name: run_web_scan
          description: "Run web application scanning"
          parameters:
            type: object
            properties:
              crawl_depth:
                type: integer
                description: "How deep to crawl"
              check_apis:
                type: boolean
                description: "Whether to check for API endpoints"
    tool_choice: auto
    exports:
      tool_calls: "{{intelligent_scan_llm_resp.tool_calls}}"
```

---

## 9. CI/CD Integration Example

### GitHub Actions Workflow

```yaml
# .github/workflows/security-scan.yml
name: Security Scan

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      target:
        description: 'Target to scan'
        required: true

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Install Osmedeus
        run: |
          curl -sL https://install.osmedeus.org | bash

      - name: Run scan
        env:
          OSM_TOKEN: ${{ secrets.OSM_TOKEN }}
        run: |
          osmedeus run -f general -t ${{ github.event.inputs.target }} --timeout 4h

      - name: Upload results
        uses: actions/upload-artifact@v3
        with:
          name: scan-results
          path: ~/workspaces-osmedeus/
```

### Osmedeus Workflow for CI Validation

```yaml
kind: module
name: ci-security-check
description: "Quick security check for CI pipelines"
tags: "ci, quick"

params:
  - name: fail_on_critical
    default: "true"

steps:
  - name: quick-scan
    type: bash
    command: >
      nuclei -u {{Target}}
      -t {{Data}}/nuclei-templates/cves/
      -severity critical,high
      -json
      -o {{Output}}/ci-scan.json
    timeout: 15m

  - name: check-results
    type: function
    depends_on:
      - quick-scan
    function: "db_vuln_critical('{{Output}}/ci-scan.json')"
    exports:
      critical_count: "{{_result}}"

  - name: fail-if-critical
    type: function
    depends_on:
      - check-results
    pre_condition: "{{fail_on_critical}} == 'true' && {{critical_count}} > 0"
    function: "exit(1)"
```
