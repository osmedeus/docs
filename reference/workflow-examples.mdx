---
title: Workflow Examples
description: Practical workflow examples for common Osmedeus use cases
---

# Workflow Examples

This document provides practical workflow examples for common security automation use cases.

## 1. Module Examples

### Basic Subdomain Enumeration

```yaml
kind: module
name: subdomain-enum
description: "Enumerate subdomains using multiple tools"
tags: "recon, subdomain"

params:
  - name: threads
    default: 10
  - name: wordlist
    default: "{{Data}}/wordlists/subdomains-top1m.txt"

steps:
  - name: subfinder
    type: bash
    command: "subfinder -d {{Target}} -all -o {{Output}}/subfinder.txt"
    timeout: 30m

  - name: amass-passive
    type: bash
    command: "amass enum -passive -d {{Target}} -o {{Output}}/amass.txt"
    timeout: 1h

  - name: merge-results
    type: function
    depends_on:
      - subfinder
      - amass-passive
    functions:
      - "appendFile('{{Output}}/all-subs.txt', '{{Output}}/subfinder.txt')"
      - "appendFile('{{Output}}/all-subs.txt', '{{Output}}/amass.txt')"
      - "sortUnix('{{Output}}/all-subs.txt', '{{Output}}/subdomains.txt')"
      - "db_total_subdomains('{{Output}}/subdomains.txt')"
    exports:
      subdomain_count: "{{_result}}"
```

### HTTP Probing with Foreach

```yaml
kind: module
name: http-probe
description: "Probe subdomains for live HTTP services"
tags: "recon, http"

params:
  - name: threads
    default: 50
  - name: timeout
    default: "10"

steps:
  - name: httpx-probe
    type: bash
    command: >
      httpx -l {{Output}}/subdomains.txt
      -threads {{threads}}
      -timeout {{timeout}}
      -json
      -o {{Output}}/httpx.jsonl
    timeout: 2h

  - name: import-results
    type: function
    depends_on:
      - httpx-probe
    functions:
      - "db_import_asset_from_file('{{Workspace}}', '{{Output}}/httpx.jsonl')"
      - "db_total_urls('{{Output}}/httpx.jsonl')"
```

### Vulnerability Scanning

```yaml
kind: module
name: vuln-scan
description: "Run vulnerability scans with Nuclei"
tags: "vuln, scan"

params:
  - name: threads
    default: 25
  - name: severity
    default: "critical,high,medium"
  - name: rate_limit
    default: 150

steps:
  - name: nuclei-scan
    type: bash
    pre_condition: "fileLength('{{Output}}/urls.txt') > 0"
    command: >
      nuclei -l {{Output}}/urls.txt
      -t {{Data}}/nuclei-templates/
      -severity {{severity}}
      -rate-limit {{rate_limit}}
      -c {{threads}}
      -json
      -o {{Output}}/nuclei.jsonl
    timeout: 4h

  - name: import-vulns
    type: function
    depends_on:
      - nuclei-scan
    functions:
      - "db_import_vuln_from_file('{{Workspace}}', '{{Output}}/nuclei.jsonl')"
      - "log_info('Vulnerabilities imported')"

  - name: notify-critical
    type: function
    depends_on:
      - import-vulns
    pre_condition: "db_select_vuln_critical() > 0"
    function: "notifyTelegram('Critical vulnerabilities found for {{Target}}')"
```

---

## 2. Flow Examples

### Full Reconnaissance Flow

```yaml
kind: flow
name: full-recon
description: "Complete reconnaissance workflow"
tags: "recon, full"

params:
  - name: threads
    default: 20

modules:
  - name: subdomain-enum
    path: modules/subdomain-enum.yaml
    params:
      threads: "{{threads}}"

  - name: http-probe
    path: modules/http-probe.yaml
    depends_on:
      - subdomain-enum
    condition: "fileLength('{{Output}}/subdomains.txt') > 0"

  - name: screenshot
    path: modules/screenshot.yaml
    depends_on:
      - http-probe
    condition: "fileLength('{{Output}}/urls.txt') > 0"

  - name: vuln-scan
    path: modules/vuln-scan.yaml
    depends_on:
      - http-probe
    params:
      threads: "{{threads}}"

  - name: report-gen
    path: modules/report-gen.yaml
    depends_on:
      - vuln-scan
      - screenshot
```

### Flow with Decision Routing

```yaml
kind: flow
name: adaptive-scan
description: "Adaptive scanning based on target size"
tags: "adaptive, smart"

modules:
  - name: initial-enum
    path: modules/quick-enum.yaml

  - name: check-size
    path: modules/count-assets.yaml
    depends_on:
      - initial-enum
    decision:
      switch: "{{asset_count_range}}"
      cases:
        "small": { goto: deep-scan }
        "medium": { goto: standard-scan }
        "large": { goto: shallow-scan }
      default: { goto: standard-scan }

  - name: deep-scan
    path: modules/deep-scan.yaml

  - name: standard-scan
    path: modules/standard-scan.yaml

  - name: shallow-scan
    path: modules/shallow-scan.yaml

  - name: finalize
    path: modules/finalize.yaml
    depends_on:
      - deep-scan
      - standard-scan
      - shallow-scan
```

---

## 3. Fragment Examples

### Common Setup Fragment

```yaml
kind: fragment
name: common-setup
description: "Common setup steps for all modules"

steps:
  - name: create-directories
    type: function
    functions:
      - "createFolder('{{Output}}/raw')"
      - "createFolder('{{Output}}/processed')"
      - "createFolder('{{Output}}/reports')"

  - name: log-start
    type: function
    function: "log_info('Starting scan for {{Target}}')"
```

### Data Cleanup Fragment

```yaml
kind: fragment
name: data-cleanup
description: "Clean and deduplicate scan results"

params:
  - name: input_file
    required: true
  - name: output_file
    required: true

steps:
  - name: sort-unique
    type: function
    function: "sortUnix('{{input_file}}', '{{output_file}}')"

  - name: remove-blanks
    type: function
    function: "remove_blank_lines('{{output_file}}')"

  - name: log-count
    type: function
    function: "log_info('Cleaned: ' + fileLength('{{output_file}}') + ' lines')"
```

### Notification Fragment

```yaml
kind: fragment
name: notify-results
description: "Send notifications with scan results"

params:
  - name: message_prefix
    default: "Scan completed"

steps:
  - name: prepare-summary
    type: function
    functions:
      - "log_info('{{message_prefix}} for {{Target}}')"

  - name: send-telegram
    type: function
    pre_condition: "os_getenv('TELEGRAM_BOT_TOKEN') != ''"
    function: >
      notifyTelegram('{{message_prefix}} for {{Target}}\n' +
        'Subdomains: ' + db_select_total_subdomains() + '\n' +
        'URLs: ' + db_select_total_urls() + '\n' +
        'Vulns: ' + db_select_total_vulns())

  - name: send-webhook
    type: function
    pre_condition: "os_getenv('WEBHOOK_URL') != ''"
    function: >
      sendWebhookEvent('scan_complete', {
        target: '{{Target}}',
        subdomains: db_select_total_subdomains(),
        vulns: db_select_total_vulns()
      })
```

---

## 4. Using Fragments in Modules

### Module with Fragment Include

```yaml
kind: module
name: subdomain-scan-with-cleanup
description: "Subdomain scan with cleanup fragment"
tags: "recon, subdomain"

includes:
  - path: fragments/common-setup.yaml
    fragment_name: setup
  - path: fragments/data-cleanup.yaml
    fragment_name: cleanup
  - path: fragments/notify-results.yaml
    fragment_name: notify

steps:
  # Run setup fragment first
  - name: run-setup
    type: fragment-step
    fragment_name: setup

  - name: subfinder
    type: bash
    depends_on:
      - run-setup
    command: "subfinder -d {{Target}} -o {{Output}}/raw/subfinder.txt"

  - name: amass
    type: bash
    depends_on:
      - run-setup
    command: "amass enum -passive -d {{Target}} -o {{Output}}/raw/amass.txt"

  - name: merge
    type: function
    depends_on:
      - subfinder
      - amass
    functions:
      - "appendFile('{{Output}}/raw/all.txt', '{{Output}}/raw/subfinder.txt')"
      - "appendFile('{{Output}}/raw/all.txt', '{{Output}}/raw/amass.txt')"

  # Run cleanup fragment with overrides
  - name: clean-results
    type: fragment-step
    depends_on:
      - merge
    fragment_name: cleanup
    override:
      input_file: "{{Output}}/raw/all.txt"
      output_file: "{{Output}}/processed/subdomains.txt"

  - name: update-db
    type: function
    depends_on:
      - clean-results
    function: "db_total_subdomains('{{Output}}/processed/subdomains.txt')"

  # Run notification fragment
  - name: notify
    type: fragment-step
    depends_on:
      - update-db
    fragment_name: notify
    override:
      message_prefix: "Subdomain enumeration completed"
```

### Fragment Chain Example

```yaml
kind: module
name: full-pipeline
description: "Full pipeline using chained fragments"

includes:
  - path: fragments/common-setup.yaml
    fragment_name: setup
  - path: fragments/data-cleanup.yaml
    fragment_name: cleanup
  - path: fragments/notify-results.yaml
    fragment_name: notify

steps:
  - name: init
    type: fragment-step
    fragment_name: setup

  - name: scan-1
    type: bash
    depends_on:
      - init
    command: "tool1 -t {{Target}} -o {{Output}}/raw/tool1.txt"

  - name: clean-1
    type: fragment-step
    depends_on:
      - scan-1
    fragment_name: cleanup
    override:
      input_file: "{{Output}}/raw/tool1.txt"
      output_file: "{{Output}}/processed/tool1.txt"

  - name: scan-2
    type: bash
    depends_on:
      - clean-1
    command: "tool2 -i {{Output}}/processed/tool1.txt -o {{Output}}/raw/tool2.txt"

  - name: clean-2
    type: fragment-step
    depends_on:
      - scan-2
    fragment_name: cleanup
    override:
      input_file: "{{Output}}/raw/tool2.txt"
      output_file: "{{Output}}/processed/final.txt"

  - name: finish
    type: fragment-step
    depends_on:
      - clean-2
    fragment_name: notify
```

---

## 5. Advanced Examples

### Remote Execution (Docker)

```yaml
kind: module
name: docker-scan
description: "Run scans in Docker containers"
tags: "docker, isolated"

steps:
  - name: nuclei-docker
    type: remote-bash
    step_runner: docker
    step_runner_config:
      image: "projectdiscovery/nuclei:latest"
      volumes:
        - "{{Output}}:/output"
        - "{{Data}}/nuclei-templates:/templates"
      network: "host"
    command: "nuclei -l /output/urls.txt -t /templates/ -o /output/nuclei.json"
    step_remote_file: "/output/nuclei.json"
    host_output_file: "{{Output}}/nuclei.json"
    timeout: 2h
```

### Remote Execution (SSH)

```yaml
kind: module
name: ssh-scan
description: "Run scans on remote server via SSH"
tags: "ssh, distributed"

params:
  - name: ssh_host
    required: true
  - name: ssh_user
    default: "scanner"
  - name: ssh_key
    default: "~/.ssh/id_rsa"

steps:
  - name: remote-nuclei
    type: remote-bash
    step_runner: ssh
    step_runner_config:
      host: "{{ssh_host}}"
      user: "{{ssh_user}}"
      key_file: "{{ssh_key}}"
      workdir: "/tmp/scan"
    command: "nuclei -l urls.txt -o results.json"
    timeout: 2h
```

### LLM-Assisted Analysis

```yaml
kind: module
name: llm-analysis
description: "Use LLM for vulnerability analysis"
tags: "llm, analysis"

steps:
  - name: load-vulns
    type: function
    function: "readFile('{{Output}}/nuclei.json')"
    exports:
      vuln_data: "{{_result}}"

  - name: analyze
    type: llm
    depends_on:
      - load-vulns
    messages:
      - role: system
        content: "You are a security analyst. Analyze vulnerabilities and provide remediation guidance."
      - role: user
        content: "Analyze these findings and prioritize them:\n{{vuln_data}}"
    llm_config:
      model: "gpt-4"
      temperature: 0.3
      max_tokens: 4000
    exports:
      analysis: "{{_result}}"

  - name: save-report
    type: function
    depends_on:
      - analyze
    function: "save_content('{{analysis}}', '{{Output}}/llm-analysis.md')"
```

### Scheduled Continuous Monitoring

```yaml
kind: module
name: continuous-monitor
description: "Continuous monitoring with diff detection"
tags: "monitor, continuous"

trigger:
  - name: daily-scan
    on: cron
    schedule: "0 2 * * *"
    enabled: true

steps:
  - name: enumerate
    type: bash
    command: "subfinder -d {{Target}} -o {{Output}}/current-subs.txt"

  - name: check-diff
    type: function
    depends_on:
      - enumerate
    functions:
      - "extractDiff('{{Output}}/baseline-subs.txt', '{{Output}}/current-subs.txt')"
    exports:
      new_subs: "{{_result}}"

  - name: notify-new
    type: function
    depends_on:
      - check-diff
    pre_condition: "len('{{new_subs}}') > 0"
    function: "notifyTelegram('New subdomains found for {{Target}}:\n{{new_subs}}')"

  - name: update-baseline
    type: function
    depends_on:
      - notify-new
    function: "moveFile('{{Output}}/current-subs.txt', '{{Output}}/baseline-subs.txt')"
```

---

## 6. CI/CD Integration Example

### GitHub Actions Workflow

```yaml
# .github/workflows/security-scan.yml
name: Security Scan

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      target:
        description: 'Target to scan'
        required: true

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Install Osmedeus
        run: |
          curl -sL https://install.osmedeus.org | bash

      - name: Run scan
        env:
          OSM_TOKEN: ${{ secrets.OSM_TOKEN }}
        run: |
          osmedeus run -f general -t ${{ github.event.inputs.target }} --timeout 4h

      - name: Upload results
        uses: actions/upload-artifact@v3
        with:
          name: scan-results
          path: ~/workspaces-osmedeus/
```

### Osmedeus Workflow for CI Validation

```yaml
kind: module
name: ci-security-check
description: "Quick security check for CI pipelines"
tags: "ci, quick"

params:
  - name: fail_on_critical
    default: "true"

steps:
  - name: quick-scan
    type: bash
    command: >
      nuclei -u {{Target}}
      -t {{Data}}/nuclei-templates/cves/
      -severity critical,high
      -json
      -o {{Output}}/ci-scan.json
    timeout: 15m

  - name: check-results
    type: function
    depends_on:
      - quick-scan
    function: "db_vuln_critical('{{Output}}/ci-scan.json')"
    exports:
      critical_count: "{{_result}}"

  - name: fail-if-critical
    type: function
    depends_on:
      - check-results
    pre_condition: "{{fail_on_critical}} == 'true' && {{critical_count}} > 0"
    function: "exit(1)"
```
